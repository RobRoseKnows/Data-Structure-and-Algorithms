/*
 * queue.c
 *
 *  Created on: Aug 15, 2016
 *      Author: wenjian
 */

#include<stdlib.h>
#include"queue.h"
#include"stack.h"
void init_queue(struct Queue* queue){
	queue->data = (int*)malloc(sizeof(int)*INIT_CAPACITY);
	queue->queue_size = INIT_CAPACITY;
	queue->head = 0;
	queue->rail = 0;
}

void enqueue(struct Queue* queue, int e){
//	if((queue->rail+1)%queue->queue_size == queue->head) increment();
	queue->data[queue->rail] = e;
	queue->rail = (queue->rail+1)%queue->queue_size;
}

int dequeue(struct Queue* queue){
//	if(queue->head == queue->rail) return;
	int e = queue->data[queue->head];
	queue->head = (queue->head+1)%queue->queue_size;
	return e;
}
int queue_peek(struct Queue* queue){
//	if(queue->head == queue->rail) return;
	int e = queue->data[queue->head];
//	queue->head = (queue->head+1)%queue->queue_size;
	return e;
}

void init_dsqueue(struct DSQueue* dsqueue){
	init_stack(&(dsqueue->s1));
	init_stack(&(dsqueue->s2));
}
void endsqueue(struct DSQueue* dsqueue, int e){
	push(&(dsqueue->s1),e);
}
int dedsqueue(struct DSQueue* dsqueue){
	if((dsqueue->s2).top > -1){//second stack has elements
		return pop(&(dsqueue->s2));
	}
	else{//second stack has not elements, pop from s1 and push to s2
		while((dsqueue->s1).top > -1){
			int e = pop(&(dsqueue->s1));
			push(&(dsqueue->s2), e);
		}
		return pop(&(dsqueue->s2));
	}
}
